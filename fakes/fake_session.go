// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"context"
	"io"
	"net"
	"os"
	"sync"

	ssh "github.com/demosdemon/go-ssh"
)

type FakeSession struct {
	CloseStub        func() error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	closeReturns struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	CloseWriteStub        func() error
	closeWriteMutex       sync.RWMutex
	closeWriteArgsForCall []struct {
	}
	closeWriteReturns struct {
		result1 error
	}
	closeWriteReturnsOnCall map[int]struct {
		result1 error
	}
	CommandStub        func() []string
	commandMutex       sync.RWMutex
	commandArgsForCall []struct {
	}
	commandReturns struct {
		result1 []string
	}
	commandReturnsOnCall map[int]struct {
		result1 []string
	}
	ContextStub        func() context.Context
	contextMutex       sync.RWMutex
	contextArgsForCall []struct {
	}
	contextReturns struct {
		result1 context.Context
	}
	contextReturnsOnCall map[int]struct {
		result1 context.Context
	}
	EnvironStub        func() []string
	environMutex       sync.RWMutex
	environArgsForCall []struct {
	}
	environReturns struct {
		result1 []string
	}
	environReturnsOnCall map[int]struct {
		result1 []string
	}
	ExitStub        func(int) error
	exitMutex       sync.RWMutex
	exitArgsForCall []struct {
		arg1 int
	}
	exitReturns struct {
		result1 error
	}
	exitReturnsOnCall map[int]struct {
		result1 error
	}
	ExitSignalStub        func(os.Signal, bool, string, string) error
	exitSignalMutex       sync.RWMutex
	exitSignalArgsForCall []struct {
		arg1 os.Signal
		arg2 bool
		arg3 string
		arg4 string
	}
	exitSignalReturns struct {
		result1 error
	}
	exitSignalReturnsOnCall map[int]struct {
		result1 error
	}
	LocalAddrStub        func() net.Addr
	localAddrMutex       sync.RWMutex
	localAddrArgsForCall []struct {
	}
	localAddrReturns struct {
		result1 net.Addr
	}
	localAddrReturnsOnCall map[int]struct {
		result1 net.Addr
	}
	LoggerStub        func() ssh.Logger
	loggerMutex       sync.RWMutex
	loggerArgsForCall []struct {
	}
	loggerReturns struct {
		result1 ssh.Logger
	}
	loggerReturnsOnCall map[int]struct {
		result1 ssh.Logger
	}
	NotifyStub        func(chan<- ssh.Signal, ...ssh.Signal)
	notifyMutex       sync.RWMutex
	notifyArgsForCall []struct {
		arg1 chan<- ssh.Signal
		arg2 []ssh.Signal
	}
	PermissionsStub        func() ssh.Permissions
	permissionsMutex       sync.RWMutex
	permissionsArgsForCall []struct {
	}
	permissionsReturns struct {
		result1 ssh.Permissions
	}
	permissionsReturnsOnCall map[int]struct {
		result1 ssh.Permissions
	}
	PtyStub        func() (ssh.Pty, <-chan ssh.Window, bool)
	ptyMutex       sync.RWMutex
	ptyArgsForCall []struct {
	}
	ptyReturns struct {
		result1 ssh.Pty
		result2 <-chan ssh.Window
		result3 bool
	}
	ptyReturnsOnCall map[int]struct {
		result1 ssh.Pty
		result2 <-chan ssh.Window
		result3 bool
	}
	PublicKeyStub        func() ssh.PublicKey
	publicKeyMutex       sync.RWMutex
	publicKeyArgsForCall []struct {
	}
	publicKeyReturns struct {
		result1 ssh.PublicKey
	}
	publicKeyReturnsOnCall map[int]struct {
		result1 ssh.PublicKey
	}
	ReadStub        func([]byte) (int, error)
	readMutex       sync.RWMutex
	readArgsForCall []struct {
		arg1 []byte
	}
	readReturns struct {
		result1 int
		result2 error
	}
	readReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	RemoteAddrStub        func() net.Addr
	remoteAddrMutex       sync.RWMutex
	remoteAddrArgsForCall []struct {
	}
	remoteAddrReturns struct {
		result1 net.Addr
	}
	remoteAddrReturnsOnCall map[int]struct {
		result1 net.Addr
	}
	ResetStub        func(...ssh.Signal)
	resetMutex       sync.RWMutex
	resetArgsForCall []struct {
		arg1 []ssh.Signal
	}
	SendRequestStub        func(string, bool, []byte) (bool, error)
	sendRequestMutex       sync.RWMutex
	sendRequestArgsForCall []struct {
		arg1 string
		arg2 bool
		arg3 []byte
	}
	sendRequestReturns struct {
		result1 bool
		result2 error
	}
	sendRequestReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	StderrStub        func() io.ReadWriter
	stderrMutex       sync.RWMutex
	stderrArgsForCall []struct {
	}
	stderrReturns struct {
		result1 io.ReadWriter
	}
	stderrReturnsOnCall map[int]struct {
		result1 io.ReadWriter
	}
	StopStub        func(chan<- ssh.Signal)
	stopMutex       sync.RWMutex
	stopArgsForCall []struct {
		arg1 chan<- ssh.Signal
	}
	UserStub        func() string
	userMutex       sync.RWMutex
	userArgsForCall []struct {
	}
	userReturns struct {
		result1 string
	}
	userReturnsOnCall map[int]struct {
		result1 string
	}
	WriteStub        func([]byte) (int, error)
	writeMutex       sync.RWMutex
	writeArgsForCall []struct {
		arg1 []byte
	}
	writeReturns struct {
		result1 int
		result2 error
	}
	writeReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSession) Close() error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if fake.CloseStub != nil {
		return fake.CloseStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.closeReturns
	return fakeReturns.result1
}

func (fake *FakeSession) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeSession) CloseCalls(stub func() error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeSession) CloseReturns(result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSession) CloseReturnsOnCall(i int, result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSession) CloseWrite() error {
	fake.closeWriteMutex.Lock()
	ret, specificReturn := fake.closeWriteReturnsOnCall[len(fake.closeWriteArgsForCall)]
	fake.closeWriteArgsForCall = append(fake.closeWriteArgsForCall, struct {
	}{})
	fake.recordInvocation("CloseWrite", []interface{}{})
	fake.closeWriteMutex.Unlock()
	if fake.CloseWriteStub != nil {
		return fake.CloseWriteStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.closeWriteReturns
	return fakeReturns.result1
}

func (fake *FakeSession) CloseWriteCallCount() int {
	fake.closeWriteMutex.RLock()
	defer fake.closeWriteMutex.RUnlock()
	return len(fake.closeWriteArgsForCall)
}

func (fake *FakeSession) CloseWriteCalls(stub func() error) {
	fake.closeWriteMutex.Lock()
	defer fake.closeWriteMutex.Unlock()
	fake.CloseWriteStub = stub
}

func (fake *FakeSession) CloseWriteReturns(result1 error) {
	fake.closeWriteMutex.Lock()
	defer fake.closeWriteMutex.Unlock()
	fake.CloseWriteStub = nil
	fake.closeWriteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSession) CloseWriteReturnsOnCall(i int, result1 error) {
	fake.closeWriteMutex.Lock()
	defer fake.closeWriteMutex.Unlock()
	fake.CloseWriteStub = nil
	if fake.closeWriteReturnsOnCall == nil {
		fake.closeWriteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeWriteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSession) Command() []string {
	fake.commandMutex.Lock()
	ret, specificReturn := fake.commandReturnsOnCall[len(fake.commandArgsForCall)]
	fake.commandArgsForCall = append(fake.commandArgsForCall, struct {
	}{})
	fake.recordInvocation("Command", []interface{}{})
	fake.commandMutex.Unlock()
	if fake.CommandStub != nil {
		return fake.CommandStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.commandReturns
	return fakeReturns.result1
}

func (fake *FakeSession) CommandCallCount() int {
	fake.commandMutex.RLock()
	defer fake.commandMutex.RUnlock()
	return len(fake.commandArgsForCall)
}

func (fake *FakeSession) CommandCalls(stub func() []string) {
	fake.commandMutex.Lock()
	defer fake.commandMutex.Unlock()
	fake.CommandStub = stub
}

func (fake *FakeSession) CommandReturns(result1 []string) {
	fake.commandMutex.Lock()
	defer fake.commandMutex.Unlock()
	fake.CommandStub = nil
	fake.commandReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeSession) CommandReturnsOnCall(i int, result1 []string) {
	fake.commandMutex.Lock()
	defer fake.commandMutex.Unlock()
	fake.CommandStub = nil
	if fake.commandReturnsOnCall == nil {
		fake.commandReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.commandReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeSession) Context() context.Context {
	fake.contextMutex.Lock()
	ret, specificReturn := fake.contextReturnsOnCall[len(fake.contextArgsForCall)]
	fake.contextArgsForCall = append(fake.contextArgsForCall, struct {
	}{})
	fake.recordInvocation("Context", []interface{}{})
	fake.contextMutex.Unlock()
	if fake.ContextStub != nil {
		return fake.ContextStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.contextReturns
	return fakeReturns.result1
}

func (fake *FakeSession) ContextCallCount() int {
	fake.contextMutex.RLock()
	defer fake.contextMutex.RUnlock()
	return len(fake.contextArgsForCall)
}

func (fake *FakeSession) ContextCalls(stub func() context.Context) {
	fake.contextMutex.Lock()
	defer fake.contextMutex.Unlock()
	fake.ContextStub = stub
}

func (fake *FakeSession) ContextReturns(result1 context.Context) {
	fake.contextMutex.Lock()
	defer fake.contextMutex.Unlock()
	fake.ContextStub = nil
	fake.contextReturns = struct {
		result1 context.Context
	}{result1}
}

func (fake *FakeSession) ContextReturnsOnCall(i int, result1 context.Context) {
	fake.contextMutex.Lock()
	defer fake.contextMutex.Unlock()
	fake.ContextStub = nil
	if fake.contextReturnsOnCall == nil {
		fake.contextReturnsOnCall = make(map[int]struct {
			result1 context.Context
		})
	}
	fake.contextReturnsOnCall[i] = struct {
		result1 context.Context
	}{result1}
}

func (fake *FakeSession) Environ() []string {
	fake.environMutex.Lock()
	ret, specificReturn := fake.environReturnsOnCall[len(fake.environArgsForCall)]
	fake.environArgsForCall = append(fake.environArgsForCall, struct {
	}{})
	fake.recordInvocation("Environ", []interface{}{})
	fake.environMutex.Unlock()
	if fake.EnvironStub != nil {
		return fake.EnvironStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.environReturns
	return fakeReturns.result1
}

func (fake *FakeSession) EnvironCallCount() int {
	fake.environMutex.RLock()
	defer fake.environMutex.RUnlock()
	return len(fake.environArgsForCall)
}

func (fake *FakeSession) EnvironCalls(stub func() []string) {
	fake.environMutex.Lock()
	defer fake.environMutex.Unlock()
	fake.EnvironStub = stub
}

func (fake *FakeSession) EnvironReturns(result1 []string) {
	fake.environMutex.Lock()
	defer fake.environMutex.Unlock()
	fake.EnvironStub = nil
	fake.environReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeSession) EnvironReturnsOnCall(i int, result1 []string) {
	fake.environMutex.Lock()
	defer fake.environMutex.Unlock()
	fake.EnvironStub = nil
	if fake.environReturnsOnCall == nil {
		fake.environReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.environReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeSession) Exit(arg1 int) error {
	fake.exitMutex.Lock()
	ret, specificReturn := fake.exitReturnsOnCall[len(fake.exitArgsForCall)]
	fake.exitArgsForCall = append(fake.exitArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("Exit", []interface{}{arg1})
	fake.exitMutex.Unlock()
	if fake.ExitStub != nil {
		return fake.ExitStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.exitReturns
	return fakeReturns.result1
}

func (fake *FakeSession) ExitCallCount() int {
	fake.exitMutex.RLock()
	defer fake.exitMutex.RUnlock()
	return len(fake.exitArgsForCall)
}

func (fake *FakeSession) ExitCalls(stub func(int) error) {
	fake.exitMutex.Lock()
	defer fake.exitMutex.Unlock()
	fake.ExitStub = stub
}

func (fake *FakeSession) ExitArgsForCall(i int) int {
	fake.exitMutex.RLock()
	defer fake.exitMutex.RUnlock()
	argsForCall := fake.exitArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) ExitReturns(result1 error) {
	fake.exitMutex.Lock()
	defer fake.exitMutex.Unlock()
	fake.ExitStub = nil
	fake.exitReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSession) ExitReturnsOnCall(i int, result1 error) {
	fake.exitMutex.Lock()
	defer fake.exitMutex.Unlock()
	fake.ExitStub = nil
	if fake.exitReturnsOnCall == nil {
		fake.exitReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.exitReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSession) ExitSignal(arg1 os.Signal, arg2 bool, arg3 string, arg4 string) error {
	fake.exitSignalMutex.Lock()
	ret, specificReturn := fake.exitSignalReturnsOnCall[len(fake.exitSignalArgsForCall)]
	fake.exitSignalArgsForCall = append(fake.exitSignalArgsForCall, struct {
		arg1 os.Signal
		arg2 bool
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("ExitSignal", []interface{}{arg1, arg2, arg3, arg4})
	fake.exitSignalMutex.Unlock()
	if fake.ExitSignalStub != nil {
		return fake.ExitSignalStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.exitSignalReturns
	return fakeReturns.result1
}

func (fake *FakeSession) ExitSignalCallCount() int {
	fake.exitSignalMutex.RLock()
	defer fake.exitSignalMutex.RUnlock()
	return len(fake.exitSignalArgsForCall)
}

func (fake *FakeSession) ExitSignalCalls(stub func(os.Signal, bool, string, string) error) {
	fake.exitSignalMutex.Lock()
	defer fake.exitSignalMutex.Unlock()
	fake.ExitSignalStub = stub
}

func (fake *FakeSession) ExitSignalArgsForCall(i int) (os.Signal, bool, string, string) {
	fake.exitSignalMutex.RLock()
	defer fake.exitSignalMutex.RUnlock()
	argsForCall := fake.exitSignalArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeSession) ExitSignalReturns(result1 error) {
	fake.exitSignalMutex.Lock()
	defer fake.exitSignalMutex.Unlock()
	fake.ExitSignalStub = nil
	fake.exitSignalReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSession) ExitSignalReturnsOnCall(i int, result1 error) {
	fake.exitSignalMutex.Lock()
	defer fake.exitSignalMutex.Unlock()
	fake.ExitSignalStub = nil
	if fake.exitSignalReturnsOnCall == nil {
		fake.exitSignalReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.exitSignalReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSession) LocalAddr() net.Addr {
	fake.localAddrMutex.Lock()
	ret, specificReturn := fake.localAddrReturnsOnCall[len(fake.localAddrArgsForCall)]
	fake.localAddrArgsForCall = append(fake.localAddrArgsForCall, struct {
	}{})
	fake.recordInvocation("LocalAddr", []interface{}{})
	fake.localAddrMutex.Unlock()
	if fake.LocalAddrStub != nil {
		return fake.LocalAddrStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.localAddrReturns
	return fakeReturns.result1
}

func (fake *FakeSession) LocalAddrCallCount() int {
	fake.localAddrMutex.RLock()
	defer fake.localAddrMutex.RUnlock()
	return len(fake.localAddrArgsForCall)
}

func (fake *FakeSession) LocalAddrCalls(stub func() net.Addr) {
	fake.localAddrMutex.Lock()
	defer fake.localAddrMutex.Unlock()
	fake.LocalAddrStub = stub
}

func (fake *FakeSession) LocalAddrReturns(result1 net.Addr) {
	fake.localAddrMutex.Lock()
	defer fake.localAddrMutex.Unlock()
	fake.LocalAddrStub = nil
	fake.localAddrReturns = struct {
		result1 net.Addr
	}{result1}
}

func (fake *FakeSession) LocalAddrReturnsOnCall(i int, result1 net.Addr) {
	fake.localAddrMutex.Lock()
	defer fake.localAddrMutex.Unlock()
	fake.LocalAddrStub = nil
	if fake.localAddrReturnsOnCall == nil {
		fake.localAddrReturnsOnCall = make(map[int]struct {
			result1 net.Addr
		})
	}
	fake.localAddrReturnsOnCall[i] = struct {
		result1 net.Addr
	}{result1}
}

func (fake *FakeSession) Logger() ssh.Logger {
	fake.loggerMutex.Lock()
	ret, specificReturn := fake.loggerReturnsOnCall[len(fake.loggerArgsForCall)]
	fake.loggerArgsForCall = append(fake.loggerArgsForCall, struct {
	}{})
	fake.recordInvocation("Logger", []interface{}{})
	fake.loggerMutex.Unlock()
	if fake.LoggerStub != nil {
		return fake.LoggerStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.loggerReturns
	return fakeReturns.result1
}

func (fake *FakeSession) LoggerCallCount() int {
	fake.loggerMutex.RLock()
	defer fake.loggerMutex.RUnlock()
	return len(fake.loggerArgsForCall)
}

func (fake *FakeSession) LoggerCalls(stub func() ssh.Logger) {
	fake.loggerMutex.Lock()
	defer fake.loggerMutex.Unlock()
	fake.LoggerStub = stub
}

func (fake *FakeSession) LoggerReturns(result1 ssh.Logger) {
	fake.loggerMutex.Lock()
	defer fake.loggerMutex.Unlock()
	fake.LoggerStub = nil
	fake.loggerReturns = struct {
		result1 ssh.Logger
	}{result1}
}

func (fake *FakeSession) LoggerReturnsOnCall(i int, result1 ssh.Logger) {
	fake.loggerMutex.Lock()
	defer fake.loggerMutex.Unlock()
	fake.LoggerStub = nil
	if fake.loggerReturnsOnCall == nil {
		fake.loggerReturnsOnCall = make(map[int]struct {
			result1 ssh.Logger
		})
	}
	fake.loggerReturnsOnCall[i] = struct {
		result1 ssh.Logger
	}{result1}
}

func (fake *FakeSession) Notify(arg1 chan<- ssh.Signal, arg2 ...ssh.Signal) {
	fake.notifyMutex.Lock()
	fake.notifyArgsForCall = append(fake.notifyArgsForCall, struct {
		arg1 chan<- ssh.Signal
		arg2 []ssh.Signal
	}{arg1, arg2})
	fake.recordInvocation("Notify", []interface{}{arg1, arg2})
	fake.notifyMutex.Unlock()
	if fake.NotifyStub != nil {
		fake.NotifyStub(arg1, arg2...)
	}
}

func (fake *FakeSession) NotifyCallCount() int {
	fake.notifyMutex.RLock()
	defer fake.notifyMutex.RUnlock()
	return len(fake.notifyArgsForCall)
}

func (fake *FakeSession) NotifyCalls(stub func(chan<- ssh.Signal, ...ssh.Signal)) {
	fake.notifyMutex.Lock()
	defer fake.notifyMutex.Unlock()
	fake.NotifyStub = stub
}

func (fake *FakeSession) NotifyArgsForCall(i int) (chan<- ssh.Signal, []ssh.Signal) {
	fake.notifyMutex.RLock()
	defer fake.notifyMutex.RUnlock()
	argsForCall := fake.notifyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSession) Permissions() ssh.Permissions {
	fake.permissionsMutex.Lock()
	ret, specificReturn := fake.permissionsReturnsOnCall[len(fake.permissionsArgsForCall)]
	fake.permissionsArgsForCall = append(fake.permissionsArgsForCall, struct {
	}{})
	fake.recordInvocation("Permissions", []interface{}{})
	fake.permissionsMutex.Unlock()
	if fake.PermissionsStub != nil {
		return fake.PermissionsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.permissionsReturns
	return fakeReturns.result1
}

func (fake *FakeSession) PermissionsCallCount() int {
	fake.permissionsMutex.RLock()
	defer fake.permissionsMutex.RUnlock()
	return len(fake.permissionsArgsForCall)
}

func (fake *FakeSession) PermissionsCalls(stub func() ssh.Permissions) {
	fake.permissionsMutex.Lock()
	defer fake.permissionsMutex.Unlock()
	fake.PermissionsStub = stub
}

func (fake *FakeSession) PermissionsReturns(result1 ssh.Permissions) {
	fake.permissionsMutex.Lock()
	defer fake.permissionsMutex.Unlock()
	fake.PermissionsStub = nil
	fake.permissionsReturns = struct {
		result1 ssh.Permissions
	}{result1}
}

func (fake *FakeSession) PermissionsReturnsOnCall(i int, result1 ssh.Permissions) {
	fake.permissionsMutex.Lock()
	defer fake.permissionsMutex.Unlock()
	fake.PermissionsStub = nil
	if fake.permissionsReturnsOnCall == nil {
		fake.permissionsReturnsOnCall = make(map[int]struct {
			result1 ssh.Permissions
		})
	}
	fake.permissionsReturnsOnCall[i] = struct {
		result1 ssh.Permissions
	}{result1}
}

func (fake *FakeSession) Pty() (ssh.Pty, <-chan ssh.Window, bool) {
	fake.ptyMutex.Lock()
	ret, specificReturn := fake.ptyReturnsOnCall[len(fake.ptyArgsForCall)]
	fake.ptyArgsForCall = append(fake.ptyArgsForCall, struct {
	}{})
	fake.recordInvocation("Pty", []interface{}{})
	fake.ptyMutex.Unlock()
	if fake.PtyStub != nil {
		return fake.PtyStub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.ptyReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeSession) PtyCallCount() int {
	fake.ptyMutex.RLock()
	defer fake.ptyMutex.RUnlock()
	return len(fake.ptyArgsForCall)
}

func (fake *FakeSession) PtyCalls(stub func() (ssh.Pty, <-chan ssh.Window, bool)) {
	fake.ptyMutex.Lock()
	defer fake.ptyMutex.Unlock()
	fake.PtyStub = stub
}

func (fake *FakeSession) PtyReturns(result1 ssh.Pty, result2 <-chan ssh.Window, result3 bool) {
	fake.ptyMutex.Lock()
	defer fake.ptyMutex.Unlock()
	fake.PtyStub = nil
	fake.ptyReturns = struct {
		result1 ssh.Pty
		result2 <-chan ssh.Window
		result3 bool
	}{result1, result2, result3}
}

func (fake *FakeSession) PtyReturnsOnCall(i int, result1 ssh.Pty, result2 <-chan ssh.Window, result3 bool) {
	fake.ptyMutex.Lock()
	defer fake.ptyMutex.Unlock()
	fake.PtyStub = nil
	if fake.ptyReturnsOnCall == nil {
		fake.ptyReturnsOnCall = make(map[int]struct {
			result1 ssh.Pty
			result2 <-chan ssh.Window
			result3 bool
		})
	}
	fake.ptyReturnsOnCall[i] = struct {
		result1 ssh.Pty
		result2 <-chan ssh.Window
		result3 bool
	}{result1, result2, result3}
}

func (fake *FakeSession) PublicKey() ssh.PublicKey {
	fake.publicKeyMutex.Lock()
	ret, specificReturn := fake.publicKeyReturnsOnCall[len(fake.publicKeyArgsForCall)]
	fake.publicKeyArgsForCall = append(fake.publicKeyArgsForCall, struct {
	}{})
	fake.recordInvocation("PublicKey", []interface{}{})
	fake.publicKeyMutex.Unlock()
	if fake.PublicKeyStub != nil {
		return fake.PublicKeyStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.publicKeyReturns
	return fakeReturns.result1
}

func (fake *FakeSession) PublicKeyCallCount() int {
	fake.publicKeyMutex.RLock()
	defer fake.publicKeyMutex.RUnlock()
	return len(fake.publicKeyArgsForCall)
}

func (fake *FakeSession) PublicKeyCalls(stub func() ssh.PublicKey) {
	fake.publicKeyMutex.Lock()
	defer fake.publicKeyMutex.Unlock()
	fake.PublicKeyStub = stub
}

func (fake *FakeSession) PublicKeyReturns(result1 ssh.PublicKey) {
	fake.publicKeyMutex.Lock()
	defer fake.publicKeyMutex.Unlock()
	fake.PublicKeyStub = nil
	fake.publicKeyReturns = struct {
		result1 ssh.PublicKey
	}{result1}
}

func (fake *FakeSession) PublicKeyReturnsOnCall(i int, result1 ssh.PublicKey) {
	fake.publicKeyMutex.Lock()
	defer fake.publicKeyMutex.Unlock()
	fake.PublicKeyStub = nil
	if fake.publicKeyReturnsOnCall == nil {
		fake.publicKeyReturnsOnCall = make(map[int]struct {
			result1 ssh.PublicKey
		})
	}
	fake.publicKeyReturnsOnCall[i] = struct {
		result1 ssh.PublicKey
	}{result1}
}

func (fake *FakeSession) Read(arg1 []byte) (int, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.readMutex.Lock()
	ret, specificReturn := fake.readReturnsOnCall[len(fake.readArgsForCall)]
	fake.readArgsForCall = append(fake.readArgsForCall, struct {
		arg1 []byte
	}{arg1Copy})
	fake.recordInvocation("Read", []interface{}{arg1Copy})
	fake.readMutex.Unlock()
	if fake.ReadStub != nil {
		return fake.ReadStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.readReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) ReadCallCount() int {
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	return len(fake.readArgsForCall)
}

func (fake *FakeSession) ReadCalls(stub func([]byte) (int, error)) {
	fake.readMutex.Lock()
	defer fake.readMutex.Unlock()
	fake.ReadStub = stub
}

func (fake *FakeSession) ReadArgsForCall(i int) []byte {
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	argsForCall := fake.readArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) ReadReturns(result1 int, result2 error) {
	fake.readMutex.Lock()
	defer fake.readMutex.Unlock()
	fake.ReadStub = nil
	fake.readReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) ReadReturnsOnCall(i int, result1 int, result2 error) {
	fake.readMutex.Lock()
	defer fake.readMutex.Unlock()
	fake.ReadStub = nil
	if fake.readReturnsOnCall == nil {
		fake.readReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.readReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) RemoteAddr() net.Addr {
	fake.remoteAddrMutex.Lock()
	ret, specificReturn := fake.remoteAddrReturnsOnCall[len(fake.remoteAddrArgsForCall)]
	fake.remoteAddrArgsForCall = append(fake.remoteAddrArgsForCall, struct {
	}{})
	fake.recordInvocation("RemoteAddr", []interface{}{})
	fake.remoteAddrMutex.Unlock()
	if fake.RemoteAddrStub != nil {
		return fake.RemoteAddrStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.remoteAddrReturns
	return fakeReturns.result1
}

func (fake *FakeSession) RemoteAddrCallCount() int {
	fake.remoteAddrMutex.RLock()
	defer fake.remoteAddrMutex.RUnlock()
	return len(fake.remoteAddrArgsForCall)
}

func (fake *FakeSession) RemoteAddrCalls(stub func() net.Addr) {
	fake.remoteAddrMutex.Lock()
	defer fake.remoteAddrMutex.Unlock()
	fake.RemoteAddrStub = stub
}

func (fake *FakeSession) RemoteAddrReturns(result1 net.Addr) {
	fake.remoteAddrMutex.Lock()
	defer fake.remoteAddrMutex.Unlock()
	fake.RemoteAddrStub = nil
	fake.remoteAddrReturns = struct {
		result1 net.Addr
	}{result1}
}

func (fake *FakeSession) RemoteAddrReturnsOnCall(i int, result1 net.Addr) {
	fake.remoteAddrMutex.Lock()
	defer fake.remoteAddrMutex.Unlock()
	fake.RemoteAddrStub = nil
	if fake.remoteAddrReturnsOnCall == nil {
		fake.remoteAddrReturnsOnCall = make(map[int]struct {
			result1 net.Addr
		})
	}
	fake.remoteAddrReturnsOnCall[i] = struct {
		result1 net.Addr
	}{result1}
}

func (fake *FakeSession) Reset(arg1 ...ssh.Signal) {
	fake.resetMutex.Lock()
	fake.resetArgsForCall = append(fake.resetArgsForCall, struct {
		arg1 []ssh.Signal
	}{arg1})
	fake.recordInvocation("Reset", []interface{}{arg1})
	fake.resetMutex.Unlock()
	if fake.ResetStub != nil {
		fake.ResetStub(arg1...)
	}
}

func (fake *FakeSession) ResetCallCount() int {
	fake.resetMutex.RLock()
	defer fake.resetMutex.RUnlock()
	return len(fake.resetArgsForCall)
}

func (fake *FakeSession) ResetCalls(stub func(...ssh.Signal)) {
	fake.resetMutex.Lock()
	defer fake.resetMutex.Unlock()
	fake.ResetStub = stub
}

func (fake *FakeSession) ResetArgsForCall(i int) []ssh.Signal {
	fake.resetMutex.RLock()
	defer fake.resetMutex.RUnlock()
	argsForCall := fake.resetArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) SendRequest(arg1 string, arg2 bool, arg3 []byte) (bool, error) {
	var arg3Copy []byte
	if arg3 != nil {
		arg3Copy = make([]byte, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.sendRequestMutex.Lock()
	ret, specificReturn := fake.sendRequestReturnsOnCall[len(fake.sendRequestArgsForCall)]
	fake.sendRequestArgsForCall = append(fake.sendRequestArgsForCall, struct {
		arg1 string
		arg2 bool
		arg3 []byte
	}{arg1, arg2, arg3Copy})
	fake.recordInvocation("SendRequest", []interface{}{arg1, arg2, arg3Copy})
	fake.sendRequestMutex.Unlock()
	if fake.SendRequestStub != nil {
		return fake.SendRequestStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.sendRequestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) SendRequestCallCount() int {
	fake.sendRequestMutex.RLock()
	defer fake.sendRequestMutex.RUnlock()
	return len(fake.sendRequestArgsForCall)
}

func (fake *FakeSession) SendRequestCalls(stub func(string, bool, []byte) (bool, error)) {
	fake.sendRequestMutex.Lock()
	defer fake.sendRequestMutex.Unlock()
	fake.SendRequestStub = stub
}

func (fake *FakeSession) SendRequestArgsForCall(i int) (string, bool, []byte) {
	fake.sendRequestMutex.RLock()
	defer fake.sendRequestMutex.RUnlock()
	argsForCall := fake.sendRequestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeSession) SendRequestReturns(result1 bool, result2 error) {
	fake.sendRequestMutex.Lock()
	defer fake.sendRequestMutex.Unlock()
	fake.SendRequestStub = nil
	fake.sendRequestReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) SendRequestReturnsOnCall(i int, result1 bool, result2 error) {
	fake.sendRequestMutex.Lock()
	defer fake.sendRequestMutex.Unlock()
	fake.SendRequestStub = nil
	if fake.sendRequestReturnsOnCall == nil {
		fake.sendRequestReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.sendRequestReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) Stderr() io.ReadWriter {
	fake.stderrMutex.Lock()
	ret, specificReturn := fake.stderrReturnsOnCall[len(fake.stderrArgsForCall)]
	fake.stderrArgsForCall = append(fake.stderrArgsForCall, struct {
	}{})
	fake.recordInvocation("Stderr", []interface{}{})
	fake.stderrMutex.Unlock()
	if fake.StderrStub != nil {
		return fake.StderrStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.stderrReturns
	return fakeReturns.result1
}

func (fake *FakeSession) StderrCallCount() int {
	fake.stderrMutex.RLock()
	defer fake.stderrMutex.RUnlock()
	return len(fake.stderrArgsForCall)
}

func (fake *FakeSession) StderrCalls(stub func() io.ReadWriter) {
	fake.stderrMutex.Lock()
	defer fake.stderrMutex.Unlock()
	fake.StderrStub = stub
}

func (fake *FakeSession) StderrReturns(result1 io.ReadWriter) {
	fake.stderrMutex.Lock()
	defer fake.stderrMutex.Unlock()
	fake.StderrStub = nil
	fake.stderrReturns = struct {
		result1 io.ReadWriter
	}{result1}
}

func (fake *FakeSession) StderrReturnsOnCall(i int, result1 io.ReadWriter) {
	fake.stderrMutex.Lock()
	defer fake.stderrMutex.Unlock()
	fake.StderrStub = nil
	if fake.stderrReturnsOnCall == nil {
		fake.stderrReturnsOnCall = make(map[int]struct {
			result1 io.ReadWriter
		})
	}
	fake.stderrReturnsOnCall[i] = struct {
		result1 io.ReadWriter
	}{result1}
}

func (fake *FakeSession) Stop(arg1 chan<- ssh.Signal) {
	fake.stopMutex.Lock()
	fake.stopArgsForCall = append(fake.stopArgsForCall, struct {
		arg1 chan<- ssh.Signal
	}{arg1})
	fake.recordInvocation("Stop", []interface{}{arg1})
	fake.stopMutex.Unlock()
	if fake.StopStub != nil {
		fake.StopStub(arg1)
	}
}

func (fake *FakeSession) StopCallCount() int {
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	return len(fake.stopArgsForCall)
}

func (fake *FakeSession) StopCalls(stub func(chan<- ssh.Signal)) {
	fake.stopMutex.Lock()
	defer fake.stopMutex.Unlock()
	fake.StopStub = stub
}

func (fake *FakeSession) StopArgsForCall(i int) chan<- ssh.Signal {
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	argsForCall := fake.stopArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) User() string {
	fake.userMutex.Lock()
	ret, specificReturn := fake.userReturnsOnCall[len(fake.userArgsForCall)]
	fake.userArgsForCall = append(fake.userArgsForCall, struct {
	}{})
	fake.recordInvocation("User", []interface{}{})
	fake.userMutex.Unlock()
	if fake.UserStub != nil {
		return fake.UserStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.userReturns
	return fakeReturns.result1
}

func (fake *FakeSession) UserCallCount() int {
	fake.userMutex.RLock()
	defer fake.userMutex.RUnlock()
	return len(fake.userArgsForCall)
}

func (fake *FakeSession) UserCalls(stub func() string) {
	fake.userMutex.Lock()
	defer fake.userMutex.Unlock()
	fake.UserStub = stub
}

func (fake *FakeSession) UserReturns(result1 string) {
	fake.userMutex.Lock()
	defer fake.userMutex.Unlock()
	fake.UserStub = nil
	fake.userReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeSession) UserReturnsOnCall(i int, result1 string) {
	fake.userMutex.Lock()
	defer fake.userMutex.Unlock()
	fake.UserStub = nil
	if fake.userReturnsOnCall == nil {
		fake.userReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.userReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeSession) Write(arg1 []byte) (int, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.writeMutex.Lock()
	ret, specificReturn := fake.writeReturnsOnCall[len(fake.writeArgsForCall)]
	fake.writeArgsForCall = append(fake.writeArgsForCall, struct {
		arg1 []byte
	}{arg1Copy})
	fake.recordInvocation("Write", []interface{}{arg1Copy})
	fake.writeMutex.Unlock()
	if fake.WriteStub != nil {
		return fake.WriteStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.writeReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) WriteCallCount() int {
	fake.writeMutex.RLock()
	defer fake.writeMutex.RUnlock()
	return len(fake.writeArgsForCall)
}

func (fake *FakeSession) WriteCalls(stub func([]byte) (int, error)) {
	fake.writeMutex.Lock()
	defer fake.writeMutex.Unlock()
	fake.WriteStub = stub
}

func (fake *FakeSession) WriteArgsForCall(i int) []byte {
	fake.writeMutex.RLock()
	defer fake.writeMutex.RUnlock()
	argsForCall := fake.writeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) WriteReturns(result1 int, result2 error) {
	fake.writeMutex.Lock()
	defer fake.writeMutex.Unlock()
	fake.WriteStub = nil
	fake.writeReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) WriteReturnsOnCall(i int, result1 int, result2 error) {
	fake.writeMutex.Lock()
	defer fake.writeMutex.Unlock()
	fake.WriteStub = nil
	if fake.writeReturnsOnCall == nil {
		fake.writeReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.writeReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.closeWriteMutex.RLock()
	defer fake.closeWriteMutex.RUnlock()
	fake.commandMutex.RLock()
	defer fake.commandMutex.RUnlock()
	fake.contextMutex.RLock()
	defer fake.contextMutex.RUnlock()
	fake.environMutex.RLock()
	defer fake.environMutex.RUnlock()
	fake.exitMutex.RLock()
	defer fake.exitMutex.RUnlock()
	fake.exitSignalMutex.RLock()
	defer fake.exitSignalMutex.RUnlock()
	fake.localAddrMutex.RLock()
	defer fake.localAddrMutex.RUnlock()
	fake.loggerMutex.RLock()
	defer fake.loggerMutex.RUnlock()
	fake.notifyMutex.RLock()
	defer fake.notifyMutex.RUnlock()
	fake.permissionsMutex.RLock()
	defer fake.permissionsMutex.RUnlock()
	fake.ptyMutex.RLock()
	defer fake.ptyMutex.RUnlock()
	fake.publicKeyMutex.RLock()
	defer fake.publicKeyMutex.RUnlock()
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	fake.remoteAddrMutex.RLock()
	defer fake.remoteAddrMutex.RUnlock()
	fake.resetMutex.RLock()
	defer fake.resetMutex.RUnlock()
	fake.sendRequestMutex.RLock()
	defer fake.sendRequestMutex.RUnlock()
	fake.stderrMutex.RLock()
	defer fake.stderrMutex.RUnlock()
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	fake.userMutex.RLock()
	defer fake.userMutex.RUnlock()
	fake.writeMutex.RLock()
	defer fake.writeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeSession) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ ssh.Session = new(FakeSession)
